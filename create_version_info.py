#!/usr/bin/env python3
import datetime
import os
import subprocess
import sys
import xml.etree.ElementTree as ET


def run_git_describe() -> str:
    p = subprocess.run(
        ["git", "describe", "--tags", "--dirty", "--always"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=False,
    )

    stdout = (p.stdout or "").strip()
    stderr = (p.stderr or "").strip()

    if p.returncode != 0:
        raise RuntimeError(f"git describe failed (exit {p.returncode}). {stderr}")

    if not stdout.strip():
        raise RuntimeError("git describe returned empty output.")

    return stdout


def parse_version(describe: str) -> str:
    parts = describe.split("-")
    version = parts[0]
    if version.startswith("v"):
        version = version[1:]
    suffix = ""
    commit_count = ""
    if len(parts) > 1:
        commit_count = "." + (parts[1] if parts[1] != "dirty" else "0")
        suffix = "-dev" if len(parts) > 2 or parts[1] == "dirty" else ""
    return f"{version}{commit_count}{suffix}"


def _escape_csharp_verbatim_string(value: str) -> str:
    return value.replace('"', '""')


def main(argv: list[str]) -> int:
    if len(argv) != 4:
        print(
            "Usage: VersionGenerator <output_path> <AssemblyName> <AssemblyGuid> <about_xml_path>"
        )
        raise ValueError("Invalid number of arguments")

    out_path = argv[0]
    ns = "ThisAssembly"

    describe = run_git_describe()
    version_long = parse_version(describe)

    parts = version_long.split("-")
    v_tokens = parts[0].split(".")
    version = parts[0]
    version_suffix = parts[1] if len(parts) > 1 else ""

    version_major = int(v_tokens[0])
    version_minor = int(v_tokens[1] if len(v_tokens) > 1 else "0")
    version_patch = int(v_tokens[2] if len(v_tokens) > 2 else "0")
    version_commits = int(v_tokens[3] if len(v_tokens) > 3 else "0")

    build_time = (
        datetime.datetime.now(datetime.timezone.utc).isoformat().replace("+00:00", "Z")
    )

    lines: list[str] = []
    lines.append("// <auto-generated />")
    lines.append(f"// Generated at {build_time}")
    lines.append(f"// Source: git describe --tags --dirty --always => {describe}")
    lines.append("")
    lines.append("internal static class ThisModInfo")
    lines.append("{")
    lines.append(f"    public const int VersionMajor = {version_major};")
    lines.append(f"    public const int VersionMinor = {version_minor};")
    lines.append(f"    public const int VersionPatch = {version_patch};")
    lines.append(f"    public const int VersionCommits = {version_commits};")
    lines.append(
        f'    public const string Version = @"{_escape_csharp_verbatim_string(version)}";'
    )
    lines.append(
        f'    public const string VersionLong = @"{_escape_csharp_verbatim_string(version_long)}";'
    )
    lines.append(
        f'    public const string VersionGit = @"{_escape_csharp_verbatim_string(describe)}";'
    )
    lines.append(
        f'    public const string VersionSuffix = @"{_escape_csharp_verbatim_string(version_suffix)}";'
    )
    lines.append(
        f'    public const string AssemblyName = @"{_escape_csharp_verbatim_string(argv[1])}";'
    )
    lines.append(
        f'    public const string AssemblyGuid = @"{_escape_csharp_verbatim_string(argv[2])}";'
    )
    lines.append(f'    public const string BuildTime = "{build_time}";')
    lines.append("}")
    lines.append("")

    content = "\n".join(lines) + "\n"

    full_out_path = os.path.abspath(out_path)
    out_dir = os.path.dirname(full_out_path)
    if out_dir:
        os.makedirs(out_dir, exist_ok=True)

    with open(out_path, "w", encoding="utf-8", newline="\n") as f:
        f.write(content)

    print(f"Wrote version {version_long} to: {out_path}")

    about_path = argv[3]
    if about_path and os.path.exists(about_path):
        with open(about_path, "r", encoding="utf-8") as f:
            xml_text = f.read()

        root = ET.fromstring(xml_text)
        version_el = root.find("Version")
        if version_el is not None:
            version_el.text = version_long

        xml_out = ET.tostring(root, encoding="unicode", method="xml")
        with open(about_path, "w", encoding="utf-8", newline="\n") as f:
            f.write(xml_out)

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
