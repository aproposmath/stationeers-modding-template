#!/usr/bin/env python3
import datetime
import os
import subprocess
import sys
import re
from pathlib import Path


def run_git_describe() -> str:
    p = subprocess.run(
        ["git", "describe", "--tags", "--dirty", "--always"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=False,
    )

    stdout = (p.stdout or "").strip()
    stderr = (p.stderr or "").strip()

    if p.returncode != 0:
        raise RuntimeError(f"git describe failed (exit {p.returncode}). {stderr}")

    if not stdout.strip():
        raise RuntimeError("git describe returned empty output.")

    return stdout


def parse_version(describe: str) -> str:
    parts = describe.split("-")
    version = parts[0]
    if version.startswith("v"):
        version = version[1:]
    suffix = ""
    commit_count = ""
    if len(parts) > 1:
        commit_count = "." + (parts[1] if parts[1] != "dirty" else "0")
        suffix = "-dev" if len(parts) > 2 or parts[1] == "dirty" else ""
    return f"{version}{commit_count}{suffix}"


def _escape_csharp_verbatim_string(value: str) -> str:
    return value.replace('"', '""')


def main(argv: list[str]) -> int:
    if len(argv) != 4:
        print(
            "Usage: VersionGenerator <output_path> <AssemblyName> <about_xml_path> <build_configuration>"
        )
        raise ValueError("Invalid number of arguments")

    out_path = argv[0]

    describe = run_git_describe()
    version_long = parse_version(describe)

    parts = version_long.split("-")
    v_tokens = parts[0].split(".")
    version = parts[0]
    version_suffix = parts[1] if len(parts) > 1 else ""

    version_major = int(v_tokens[0])
    version_minor = int(v_tokens[1] if len(v_tokens) > 1 else "0")
    version_patch = int(v_tokens[2] if len(v_tokens) > 2 else "0")
    version_commits = int(v_tokens[3] if len(v_tokens) > 3 else "0")

    build_time = (
        datetime.datetime.now(datetime.timezone.utc).isoformat().replace("+00:00", "Z")
    )
    about_path = Path(argv[2])
    build_type = argv[3].strip().lower()

    if not about_path.exists():
        raise FileNotFoundError(f"About file not found: {about_path}")

    about_xml = about_path.read_text()
    mod_id = re.search(r"<ModID>(.*?)</ModID>", about_xml).group(1)

    lines: list[str] = []
    lines.append("// <auto-generated />")
    lines.append(f"// Generated at {build_time}")
    lines.append(f"// Source: git describe --tags --dirty --always => {describe}")
    lines.append("")
    lines.append("internal static class ThisModInfo")
    lines.append("{")
    lines.append(f"    public const int VersionMajor = {version_major};")
    lines.append(f"    public const int VersionMinor = {version_minor};")
    lines.append(f"    public const int VersionPatch = {version_patch};")
    lines.append(f"    public const int VersionCommits = {version_commits};")
    lines.append(
        f'    public const string Version = @"{_escape_csharp_verbatim_string(version)}";'
    )
    lines.append(
        f'    public const string VersionLong = @"{_escape_csharp_verbatim_string(version_long)}";'
    )
    lines.append(
        f'    public const string VersionGit = @"{_escape_csharp_verbatim_string(describe)}";'
    )
    lines.append(
        f'    public const string VersionSuffix = @"{_escape_csharp_verbatim_string(version_suffix)}";'
    )
    lines.append(
        f'    public const string AssemblyName = @"{_escape_csharp_verbatim_string(argv[1])}";'
    )
    lines.append(
        f'    public const string AssemblyGuid = @"{_escape_csharp_verbatim_string(mod_id)}";'
    )
    lines.append(f'    public const string BuildTime = "{build_time}";')
    lines.append("}")
    lines.append("")

    content = "\n".join(lines) + "\n"

    full_out_path = os.path.abspath(out_path)
    out_dir = os.path.dirname(full_out_path)
    if out_dir:
        os.makedirs(out_dir, exist_ok=True)

    with open(out_path, "w", encoding="utf-8", newline="\n") as f:
        f.write(content)

    print(f"Wrote version {version_long} to: {out_path}")

    if build_type == "release":
        # Replace the first occurrence of <Version>...</Version>
        pattern = r"(<Version>)(.*?)(</Version>)"

        def _repl(m: re.Match) -> str:
            return m.group(1) + version_long + m.group(3)

        xml_out, n = re.subn(pattern, _repl, about_xml, count=1, flags=re.DOTALL)

        if n > 0:
            about_path.write_text(xml_out)
            print(f"Wrote version {version_long} to: {about_path}")
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
